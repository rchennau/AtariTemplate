;
; File generated by cc65 v 2.19 - Git 52e438792
;
	.fopt		compiler,"cc65 v 2.19 - Git 52e438792"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.import		_strlen
	.import		_memcpy
	.import		__graphics
	.import		_cprintf
	.export		_str_to_internal
	.import		_text
	.export		_wait
	.export		_graphics2
	.export		_i
	.export		_main

.segment	"DATA"

_i:
	.byte	$00

.segment	"RODATA"

S0002:
	.byte	$54,$68,$69,$73,$20,$77,$61,$73,$20,$69,$74,$00

; ---------------------------------------------------------------
; void __near__ __fastcall__ str_to_internal (char *s)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_str_to_internal: near

.segment	"CODE"

;
; void __fastcall__ str_to_internal(char *s) {
;
	jsr     pushax
;
; len = strlen(s);
;
	jsr     ldax0sp
	jsr     _strlen
	sta     M0002
;
; for (i = 0; i < len; i++) {
;
	lda     #$00
	sta     M0001
L000E:	lda     M0001
	cmp     M0002
	bcs     L0001
;
; if (s[i] < 32)
;
	jsr     ldax0sp
	ldy     M0001
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$20
	bcs     L0006
;
; s[i] += 64;
;
	jsr     ldax0sp
	clc
	adc     M0001
	bcc     L000A
	inx
L000A:	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	clc
	adc     #$40
;
; else if (s[i] < 96)
;
	jmp     L000D
L0006:	jsr     ldax0sp
	ldy     M0001
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$60
	bcs     L000F
;
; s[i] -= 32;
;
	jsr     ldax0sp
	clc
	adc     M0001
	bcc     L000C
	inx
L000C:	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sec
	sbc     #$20
L000D:	sta     (ptr1),y
;
; for (i = 0; i < len; i++) {
;
L000F:	inc     M0001
	jmp     L000E
;
; }
;
L0001:	jmp     incsp2

.segment	"BSS"

M0001:
	.res	1,$00
M0002:
	.res	1,$00

.endproc

; ---------------------------------------------------------------
; void __near__ wait (unsigned char t)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_wait: near

.segment	"CODE"

;
; void wait(BYTE t) {
;
	jsr     pusha
;
; OS.rtclok[0]=OS.rtclok[1]=OS.rtclok[2]=0; 
;
	lda     #$00
	sta     $0014
	sta     $0013
	sta     $0012
;
; while (OS.rtclok[2]<t); { 
;
L0005:	lda     $0014
	ldy     #$00
	cmp     (sp),y
	bcc     L0005
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ graphics2 (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_graphics2: near

.segment	"CODE"

;
; BYTE i = 0; 
;
	lda     #$00
	sta     M0001
;
; _graphics(2);     // change to gr.2
;
	lda     #$02
	jsr     __graphics
;
; screen = (char *) SAVMSC; // asign the screen address to a var 
;
	lda     $0058+1
	sta     M0002+1
	lda     $0058
	sta     M0002
;
; memcpy(txt, text, strlen(text)+1);  // Confusing but to convert to internal screen format we need a non-constant copy of our constant string 
;
	lda     #<(M0003)
	ldx     #>(M0003)
	jsr     pushax
	lda     #<(_text)
	ldx     #>(_text)
	jsr     pushax
	lda     #<(_text)
	ldx     #>(_text)
	jsr     _strlen
	jsr     incax1
	jsr     _memcpy
;
; str_to_internal(txt);  // convert content of text.s to internal screen format (Atasci) 
;
	lda     #<(M0003)
	ldx     #>(M0003)
	jsr     _str_to_internal
;
; memcpy(&screen[20], txt, strlen(text)); // Copy the content of text to the pointer to the memory address labled screen (copy into RAM). 
;
	lda     M0002
	ldx     M0002+1
	ldy     #$14
	jsr     incaxy
	jsr     pushax
	lda     #<(M0003)
	ldx     #>(M0003)
	jsr     pushax
	lda     #<(_text)
	ldx     #>(_text)
	jsr     _strlen
	jmp     _memcpy

.segment	"BSS"

M0001:
	.res	1,$00
M0002:
	.res	2,$00
M0003:
	.res	15,$00

.endproc

; ---------------------------------------------------------------
; int __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; graphics2();
;
	jsr     _graphics2
;
; wait(50);
;
	lda     #$32
	jsr     _wait
;
; cprintf("This was it");
;
	lda     #<(S0002)
	ldx     #>(S0002)
	jsr     pushax
	ldy     #$02
	jsr     _cprintf
;
; wait(50);
;
	lda     #$32
	jsr     _wait
;
; return 0;
;
	ldx     #$00
	txa
;
; }
;
	rts

.endproc

